<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>360 Room - Boundary Debug</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; touch-action: none; }
        #joystick-zone {
            position: absolute; bottom: 50px; left: 50px;
            width: 120px; height: 120px; z-index: 100;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div id="joystick-zone"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. KHỞI TẠO ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0.6, 0); 

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const lim = 30; // Biên độ di chuyển

        // --- 2. HIỂN THỊ BIÊN & SÀN (DEBUG) ---

        // A. Mặt sàn kính có lưới (Glass Grid Floor)
        const floorGeo = new THREE.PlaneGeometry(lim * 2, lim * 2);
        const floorMat = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff, 
            wireframe: true, 
            transparent: true, 
            opacity: 0.15 
        });
        const visualFloor = new THREE.Mesh(floorGeo, floorMat);
        visualFloor.rotation.x = -Math.PI / 2;
        visualFloor.position.y = 0; // Đặt đúng mặt sàn vật lý
        scene.add(visualFloor);

        // B. Vòng tròn biên giới (Boundary Circle)
        const ringGeo = new THREE.TorusGeometry(lim, 0.05, 16, 100);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0xff0055 });
        const boundaryRing = new THREE.Mesh(ringGeo, ringMat);
        boundaryRing.rotation.x = Math.PI / 2;
        boundaryRing.position.y = 0.01; 
        scene.add(boundaryRing);

        // --- 3. PHÔNG NỀN 360 ---
        const loader = new THREE.TextureLoader();
        loader.load('phong02.webp', (texture) => {
            texture.colorSpace = THREE.SRGBColorSpace;
            const geometry = new THREE.SphereGeometry(100, 60, 40); // Tăng lên 100 để bao quát hơn
            geometry.scale(1, 0.99, 1); 
            const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide });
            const skybox = new THREE.Mesh(geometry, material);
            scene.add(skybox);
        });

        // --- 4. HỆ THỐNG ĐIỀU KHIỂN ---
        let moveState = { f: 0, r: 0 };
        let look = { lat: 0, lon: -90 };
        let interact = false;
        let px, py, plon, plat;

        const joy = nipplejs.create({ 
            zone: document.getElementById('joystick-zone'), 
            mode: 'static', 
            position: {left: '60px', bottom: '60px'}, 
            color: 'cyan' 
        });

        joy.on('move', (e, d) => { moveState.f = d.vector.y; moveState.r = d.vector.x; });
        joy.on('end', () => { moveState = { f: 0, r: 0 }; });

        document.addEventListener('pointerdown', e => { 
            if(e.clientX > 200) { interact = true; px = e.clientX; py = e.clientY; plon = look.lon; plat = look.lat; }
        });
        document.addEventListener('pointermove', e => {
            if (interact) {
                look.lon = (px - e.clientX) * 0.2 + plon;
                look.lat = (e.clientY - py) * 0.2 + plat;
            }
        });
        document.addEventListener('pointerup', () => interact = false);

        // --- 5. ANIMATE ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();

            look.lat = Math.max(-85, Math.min(85, look.lat));
            const phi = THREE.MathUtils.degToRad(90 - look.lat);
            const theta = THREE.MathUtils.degToRad(look.lon);
            const target = new THREE.Vector3().setFromSphericalCoords(1, phi, theta).add(camera.position);
            camera.lookAt(target);

            if (moveState.f !== 0 || moveState.r !== 0) {
                const speed = 8 * dt; // Tăng tốc độ một chút cho đỡ chật
                const dir = new THREE.Vector3();
                camera.getWorldDirection(dir);
                dir.y = 0; dir.normalize();
                const side = new THREE.Vector3().crossVectors(camera.up, dir).normalize();
                camera.position.addScaledVector(dir, moveState.f * speed);
                camera.position.addScaledVector(side, -moveState.r * speed);
            }

            // Xử lý chặn biên theo hình tròn (thay vì hình vuông cũ)
            const dist = Math.sqrt(camera.position.x**2 + camera.position.z**2);
            if (dist > lim) {
                const angle = Math.atan2(camera.position.z, camera.position.x);
                camera.position.x = Math.cos(angle) * lim;
                camera.position.z = Math.sin(angle) * lim;
            }

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
